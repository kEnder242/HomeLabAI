from mcp.server.fastmcp import FastMCP
import logging
import sys
import os
import json
import glob
import re

# Logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - [ARCHITECT] %(levelname)s - %(message)s',
    stream=sys.stderr
)

mcp = FastMCP("The Architect")

# Paths
FIELD_NOTES_DATA = os.path.expanduser("~/Dev_Lab/Portfolio_Dev/field_notes/data")
SEMANTIC_MAP_FILE = os.path.join(FIELD_NOTES_DATA, "semantic_map.json")


@mcp.tool()
async def generate_bkm(topic: str, category: str = "validation") -> str:
    """The Blueprint Generator: Creates a high-density BKM template."""
    template = f"""# BKM: {topic.upper()}
**Category:** {category.capitalize()}
**Status:** DRAFT (Architect Node)

## ðŸŽï¸ 1. Execution (One-Liner)
`[Insert critical command here]`

## ðŸ§ª 2. Validation Logic
- [ ] Step 1: Verify [X]
- [ ] Step 2: Monitor [Y]

## ðŸ¤• 3. Scars (Known Failures)
- Failure A: [Describe] -> Mitigation: [Describe]

---
*Generated by The Architect*
"""
    return template


@mcp.tool()
async def build_semantic_map() -> str:
    """Scans artifacts and refactors them into hierarchy."""
    logging.info("Architect is refactoring hierarchy...")
    artifacts = glob.glob(os.path.join(FIELD_NOTES_DATA, "20*.json"))
    hierarchy = {
        "strategic": [],
        "technical_themes": {},
        "tactical_count": 0
    }
    theme_keywords = ["telemetry", "silicon", "validation", "automation"]

    for art_path in artifacts:
        year = os.path.basename(art_path).replace(".json", "")
        try:
            with open(art_path, 'r') as f:
                data = json.load(f)
                if not isinstance(data, list):
                    continue
                hierarchy["tactical_count"] += len(data)
                for item in data:
                    rank = item.get('rank', 2)
                    summary = item.get('summary', '')
                    if rank >= 4:
                        hierarchy["strategic"].append({
                            "year": year, "summary": summary,
                            "gem": item.get('technical_gem', '')
                        })
                    for kw in theme_keywords:
                        if kw in summary.lower():
                            if kw not in hierarchy["technical_themes"]:
                                hierarchy["technical_themes"][kw] = []
                            hierarchy["technical_themes"][kw].append({
                                "year": year, "summary": summary
                            })
        except Exception:
            pass

    for kw in hierarchy["technical_themes"]:
        hierarchy["technical_themes"][kw] = hierarchy["technical_themes"][kw][:10]

    with open(SEMANTIC_MAP_FILE, 'w') as f:
        json.dump(hierarchy, f, indent=2)

    return f"Hierarchy refactored. {len(hierarchy['strategic'])} anchors identified."


@mcp.tool()
async def close_lab() -> str:
    """The Master Switch: Gracefully shuts down the Mind."""
    return json.dumps({
        "status": "shutdown",
        "message": "Acme Lab is closing. Goodnight."
    })


@mcp.tool()
async def triage_response(raw_text: str) -> str:
    """
    The Cognitive Dispatcher: Aggressive Extraction Filter.
    Strips conversational prefixes and malformed tool names.
    Returns: A clean JSON Tool Call block or 'TEXT'.
    """
    valid_tools = [
        "ask_brain", "deep_think", "list_cabinet", 
        "read_document", "close_lab", "generate_bkm", 
        "access_personal_history"
    ]
    
    # 1. Strip common model prefixes
    clean_text = re.sub(
        r'^(pinky|brain|system|narf|poit|tool)[:!\s]*', 
        '', raw_text, flags=re.IGNORECASE
    ).strip()
    
    # 2. Extract all JSON-like blocks
    matches = re.findall(r'(\{.*?\})', clean_text, re.DOTALL)
    
    for m in matches:
        try:
            data = json.loads(m)
            tool = data.get("tool")
            
            # 3. Correct malformed tool names (strip parentheses)
            if tool:
                tool = tool.replace('()', '').replace('[]', '').strip()
                data["tool"] = tool
            else:
                # 4. Deep Search: Check values for tool names
                for val in data.values():
                    if isinstance(val, str):
                        for vt in valid_tools:
                            if vt in val.lower():
                                return json.dumps({"tool": vt, "parameters": {}})
            
            # If it's a known tool, return ONLY the clean JSON
            if tool in valid_tools:
                return json.dumps(data)
            
            # Handle reply_to_user special case
            if not tool and "reply_to_user" in data:
                return json.dumps(data)
                
        except json.JSONDecodeError:
            continue
            
    return "TEXT"


if __name__ == "__main__":
    mcp.run()
